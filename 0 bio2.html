<!DOCTYPE html>
<html>
<head>
  <title>Shader App w/ Schemes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin: 0; overflow: hidden; background: black; font-family: monospace; }
    canvas#shaderCanvas { width: 100vw; height: 100vh; display: block; }
    canvas#ampGraph {
      position: fixed; bottom: 130px; left: 0;
      width: 100vw; height: 60px;
      background: rgba(0,0,0,0.3); z-index: 5;
    }
    #status, #controls {
      position: fixed; width: 100%; z-index: 6;
      font-size: 14px; color: white; padding: 8px;
      background: rgba(0,0,0,0.7);
    }
    #status { top: 0; }
    #controls {
      bottom: 0; display: flex; flex-wrap: wrap;
      gap: 8px; align-items: center;
    }
    select, input[type=range], button {
      padding: 4px; font-family: monospace; font-size: 14px;
    }
    #editor { display:none; position:fixed; top:0; left:0; width:100%; height:100%; z-index:10; background:white; padding:10px; }
    #editor textarea { width:100%; height:90%; font-family:monospace; }
  </style>
</head>
<body>
<canvas id="shaderCanvas"></canvas>
<canvas id="ampGraph"></canvas>
<div id="status">[OK] Initialized</div>
<div id="controls">
  <select id="schemeSelect"></select>
  <label>Boost <input type="range" id="boost" min="1" max="10" step="0.1" value="4"></label>
  <label>Baseline <input type="range" id="baseline" min="0" max="0.5" step="0.01" value="0.1"></label>
  <label>Smooth <input type="range" id="smoothing" min="0" max="1" step="0.01" value="0.3"></label>
  <button onclick="toggleEditor()">Edit</button>
  <button onclick="loadSchemes()">Import Schemes</button>
  <button onclick="exportCurrent()">Export Shader</button>
</div>
<div id="editor">
  <textarea id="customShader"></textarea><br>
  <button onclick="saveShader()">Save</button>
  <button onclick="toggleEditor()">Cancel</button>
</div>

<script>
let gl, program, canvas, audioContext, analyser;
let ampHistory = Array(500).fill(0);
let activeShader = '';
let schemes = {};
let currentParams = { boost: 4, baseline: 0.1, smoothing: 0.3 };
let smoothedAmp = 0.2;

function showStatus(msg, err=false) {
  const s = document.getElementById('status');
  s.textContent = (err ? '[ERROR] ' : '[OK] ') + msg;
  s.style.color = err ? 'red' : 'lightgreen';
}

function initGL() {
  canvas = document.getElementById('shaderCanvas');
  gl = canvas.getContext('webgl');
  if (!gl) return showStatus("WebGL not supported", true);
  window.addEventListener('resize', resize);
  resize();
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}

function compile(src) {
  const vsSrc = `precision mediump float; attribute vec2 position; void main(){gl_Position=vec4(position,0,1);}`;
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, src); gl.compileShader(fs);
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) return null;
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
  return gl.getProgramParameter(prog, gl.LINK_STATUS) ? prog : null;
}

function loadShader(name, shaderCode) {
  const p = compile(shaderCode);
  if (!p) return;
  program = p;
  gl.useProgram(program);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1, 1, -1, -1, 1, 1, 1
  ]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  activeShader = shaderCode;
  showStatus(`Loaded: ${name}`);
}

function render() {
  const amp = getAmp();
  smoothedAmp = smoothedAmp * (1 - currentParams.smoothing) + amp * currentParams.smoothing;
  ampHistory.push(smoothedAmp);
  ampHistory.shift();
  resize();
  const res = gl.getUniformLocation(program, 'iResolution');
  const t = gl.getUniformLocation(program, 'iTime');
  const a = gl.getUniformLocation(program, 'breathAmplitude');
  gl.clear(gl.COLOR_BUFFER_BIT);
  if (res) gl.uniform2f(res, canvas.width, canvas.height);
  if (t) gl.uniform1f(t, performance.now() / 1000);
  if (a) gl.uniform1f(a, smoothedAmp);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  drawAmpGraph();
  showStatus(`Amp: ${smoothedAmp.toFixed(3)}`);
}

function loop() {
  render();
  requestAnimationFrame(loop);
}

function getAmp() {
  if (!analyser) return currentParams.baseline;
  const data = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(data);
  let avg = data.reduce((a,b)=>a+b) / data.length / 255;
  return Math.min(1.0, Math.max(currentParams.baseline, avg * currentParams.boost));
}

function drawAmpGraph() {
  const g = document.getElementById('ampGraph');
  const ctx = g.getContext('2d');
  g.width = g.clientWidth;
  g.height = g.clientHeight;
  ctx.clearRect(0, 0, g.width, g.height);
  ctx.beginPath();
  ctx.moveTo(0, g.height * (1 - ampHistory[0]));
  for (let i = 1; i < ampHistory.length; i++) {
    const x = i / ampHistory.length * g.width;
    const y = g.height * (1 - ampHistory[i]);
    ctx.lineTo(x, y);
  }
  ctx.strokeStyle = '#00FFAA';
  ctx.lineWidth = 2;
  ctx.stroke();
}

async function setupAudio() {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioContext.createMediaStreamSource(stream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;
    source.connect(analyser);
    showStatus("Microphone connected.");
  } catch (e) {
    showStatus("Mic error: " + e.message, true);
  }
}

function loadSchemes() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = () => {
    const file = input.files[0];
    const reader = new FileReader();
    reader.onload = e => {
      const json = JSON.parse(e.target.result);
      schemes = {};
      const sel = document.getElementById('schemeSelect');
      sel.innerHTML = '';
      json.schemes.forEach(s => {
        schemes[s.name] = s;
        const opt = document.createElement('option');
        opt.value = s.name;
        opt.textContent = s.name;
        sel.appendChild(opt);
      });
      sel.onchange = () => {
        const chosen = schemes[sel.value];
        currentParams = { ...chosen.params };
        document.getElementById('boost').value = currentParams.boost;
        document.getElementById('baseline').value = currentParams.baseline;
        document.getElementById('smoothing').value = currentParams.smoothing;
        loadShader(sel.value, chosen.shader);
      };
      sel.selectedIndex = 0;
      sel.onchange();
    };
    reader.readAsText(file);
  };
  input.click();
}

function toggleEditor() {
  const e = document.getElementById('editor');
  const ta = document.getElementById('customShader');
  if (e.style.display === 'none') {
    ta.value = activeShader;
    e.style.display = 'block';
  } else {
    e.style.display = 'none';
  }
}

function saveShader() {
  activeShader = document.getElementById('customShader').value;
  const sel = document.getElementById('schemeSelect');
  loadShader(sel.value, activeShader);
  toggleEditor();
}

function exportCurrent() {
  const blob = new Blob([activeShader], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'shader.frag';
  a.click();
  URL.revokeObjectURL(url);
}

// calibration link
['boost','baseline','smoothing'].forEach(id => {
  document.getElementById(id).oninput = () => {
    currentParams[id] = parseFloat(document.getElementById(id).value);
  };
});

initGL();
setupAudio();
loop();
</script>
</body>
</html>