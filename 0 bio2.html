<!DOCTYPE html>
<html>
<head>
  <title>Shader App â€“ Diagnostic</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin: 0; overflow: hidden; background: black; }
    canvas#shaderCanvas { width: 100vw; height: 100vh; display: block; }
    canvas#amplitudeGraph {
      position: fixed; bottom: 40px; left: 0;
      width: 100vw; height: 60px;
      z-index: 5;
      background: rgba(0,0,0,0.3);
    }
    #status, #controls {
      position: fixed; width: 100%; z-index: 6;
      font-family: monospace; font-size: 14px; color: white; padding: 8px;
      background: rgba(0,0,0,0.7);
    }
    #status { top: 0; }
    #controls { bottom: 0; display: flex; gap: 8px; align-items: center; }
    select, button { padding: 5px; font-family: monospace; font-size: 14px; }
  </style>
</head>
<body>
<canvas id="shaderCanvas"></canvas>
<canvas id="amplitudeGraph"></canvas>
<div id="status">[OK] Starting...</div>
<div id="controls">
  <select id="shaderList">
    <option value="plasma">Plasma</option>
    <option value="bars">VU Bars</option>
    <option value="firepulse">Fire Pulse</option>
    <option value="custom">Custom</option>
  </select>
  <button onclick="toggleEditor()">Edit</button>
  <button onclick="importShader()">Import</button>
  <button onclick="exportShader()">Export</button>
  <button onclick="unlockAudio()">Unlock Audio</button>
</div>
<div id="shaderEditor" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:white; z-index:10; padding:10px;">
  <textarea id="customShader" style="width:100%; height:90%; font-family:monospace;"></textarea><br>
  <button onclick="saveCustomShader()">Save</button>
  <button onclick="toggleEditor()">Cancel</button>
</div>

<script>
let gl, program, canvas, audioContext, analyser;
let customCode = '';
let ampHistory = Array(500).fill(0);
const builtInShaders = {
  plasma: `
    precision mediump float;
    uniform float iTime;
    uniform float breathAmplitude;
    uniform vec2 iResolution;
    void main() {
      vec2 uv = (gl_FragCoord.xy / iResolution) * 2.0 - 1.0;
      float len = length(uv);
      float angle = atan(uv.y, uv.x);
      float color = 0.5 + 0.5 * cos(10.0 * len + iTime * 3.0 + breathAmplitude * 10.0 + angle);
      gl_FragColor = vec4(vec3(color * 0.8, color * 0.3 + 0.2, color), 1.0);
    }
  `,
  bars: `
    precision mediump float;
    uniform float iTime;
    uniform float breathAmplitude;
    uniform vec2 iResolution;
    void main() {
      vec2 uv = gl_FragCoord.xy / iResolution;
      float bar = step(1.0 - breathAmplitude, uv.y);
      gl_FragColor = mix(vec4(0.0, 1.0, 0.2, 1.0), vec4(0), bar);
    }
  `,
  firepulse: `
    precision mediump float;
    uniform float iTime;
    uniform float breathAmplitude;
    uniform vec2 iResolution;
    float noise(vec2 p) {
      return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
    }
    void main() {
      vec2 uv = gl_FragCoord.xy / iResolution;
      float t = iTime * 0.5 + breathAmplitude * 3.0;
      float n = noise(uv * 10.0 + vec2(t));
      float glow = smoothstep(0.4, 0.6, n);
      gl_FragColor = vec4(glow * vec3(1.0, 0.3 + breathAmplitude, 0.0), 1.0);
    }
  `
};

function showStatus(msg, err = false) {
  const el = document.getElementById('status');
  el.textContent = (err ? '[ERROR] ' : '[OK] ') + msg;
  el.style.color = err ? 'red' : 'lightgreen';
}

function initGL() {
  canvas = document.getElementById('shaderCanvas');
  gl = canvas.getContext('webgl');
  if (!gl) return showStatus("WebGL not supported", true);
  window.addEventListener('resize', resizeCanvas);
  document.getElementById('shaderList').onchange = () => loadShader(document.getElementById('shaderList').value);
  resizeCanvas();
  loadShader('plasma');
}

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}

function compile(src) {
  const vsSrc = `precision mediump float; attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) return null;
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, src); gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
  return gl.getProgramParameter(prog, gl.LINK_STATUS) ? prog : null;
}

function loadShader(name) {
  const src = builtInShaders[name] || customCode;
  const p = compile(src);
  if (!p) return;
  program = p;
  gl.useProgram(program);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1, 1,1
  ]), gl.STATIC_DRAW);
  const pos = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(pos);
  gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
  showStatus(`Shader loaded: ${name}`);
}

function render() {
  const amp = getBreathAmplitude();
  ampHistory.push(amp);
  ampHistory.shift();

  resizeCanvas();
  gl.clear(gl.COLOR_BUFFER_BIT);
  const t = gl.getUniformLocation(program, 'iTime');
  const a = gl.getUniformLocation(program, 'breathAmplitude');
  const res = gl.getUniformLocation(program, 'iResolution');
  if (t) gl.uniform1f(t, performance.now() / 1000);
  if (a) gl.uniform1f(a, amp);
  if (res) gl.uniform2f(res, canvas.width, canvas.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  drawAmplitudeGraph(ampHistory);
  showStatus(`Mic Level: ${amp.toFixed(3)}`);
}

function loop() {
  render();
  requestAnimationFrame(loop);
}

function getBreathAmplitude() {
  if (!analyser) return 0.3;
  const data = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(data);
  return Math.min(1.0, Math.max(0.05, data.reduce((a,b) => a + b) / data.length / 255 * 4));
}

async function setupAudio() {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioContext.createMediaStreamSource(stream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;
    source.connect(analyser);
    showStatus("Microphone connected.");
  } catch (e) {
    showStatus("Mic error: " + e.message, true);
  }
}

function unlockAudio() {
  if (audioContext && audioContext.state === 'suspended') {
    audioContext.resume().then(() => showStatus("AudioContext resumed."));
  }
}

function toggleEditor() {
  const ed = document.getElementById('shaderEditor');
  const ta = document.getElementById('customShader');
  if (ed.style.display === 'none') {
    ta.value = customCode || builtInShaders.plasma;
    ed.style.display = 'block';
  } else {
    ed.style.display = 'none';
  }
}

function saveCustomShader() {
  customCode = document.getElementById('customShader').value;
  document.getElementById('shaderList').value = 'custom';
  loadShader('custom');
  toggleEditor();
}

function importShader() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.frag,.glsl,.txt';
  input.onchange = () => {
    const file = input.files[0];
    const reader = new FileReader();
    reader.onload = e => {
      customCode = e.target.result;
      document.getElementById('shaderList').value = 'custom';
      loadShader('custom');
    };
    reader.readAsText(file);
  };
  input.click();
}

function exportShader() {
  const blob = new Blob([customCode], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'custom_shader.frag';
  a.click();
  URL.revokeObjectURL(url);
}

function drawAmplitudeGraph(data) {
  const graph = document.getElementById('amplitudeGraph');
  const ctx = graph.getContext('2d');
  graph.width = graph.clientWidth;
  graph.height = graph.clientHeight;
  ctx.clearRect(0, 0, graph.width, graph.height);
  ctx.beginPath();
  ctx.moveTo(0, graph.height * (1 - data[0]));
  for (let i = 1; i < data.length; i++) {
    const x = (i / data.length) * graph.width;
    const y = graph.height * (1 - data[i]);
    ctx.lineTo(x, y);
  }
  ctx.strokeStyle = '#00FFAA';
  ctx.lineWidth = 2;
  ctx.stroke();
}

initGL();
setupAudio();
loop();
</script>
</body>
</html>