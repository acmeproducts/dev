<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Image Visualization Modes</title>
<style>
  body { font-family: sans-serif; margin: 0; background: #222; color: #eee; }
  #controls { background: #333; padding: 8px; display: flex; flex-wrap: wrap; align-items: center; }
  #controls > * { margin: 4px 8px; }
  select, input[type=range], input[type=file] {
    background: #222; color: #fff; border: 1px solid #555; padding: 2px 4px;
  }
  label { font-size: 0.9em; margin-right: 4px; }
  canvas { display: block; width: 100%; height: auto; background: #000; }
</style>
</head>
<body>
<div id="controls">
  <label for="modeSelect">Mode:</label>
  <select id="modeSelect">
    <option value="1">Mode 1 – Static</option>
    <option value="2" selected>Mode 2 – Wave</option>
    <option value="3">Mode 3 – Ripple (Drag)</option>
    <option value="4">Mode 4 – Kaleidoscope</option>
    <option value="5">Mode 5 – Liquid (Tilt)</option>
    <option value="6">Mode 6 – Histogram</option>
    <option value="7">Mode 7 – Scatter</option>
  </select>
  <label for="imgSelect">Image:</label>
  <select id="imgSelect">
    <option value="default">Default Image</option>
    <!-- user images will be appended here -->
  </select>
  <input type="file" id="fileInput" accept="image/*" multiple style="display:none;">
  <button id="addImageBtn">Add Image</button>
  <!-- Controls that show/hide depending on mode: -->
  <label id="histToggleLabel" style="display:none;">
    <input type="checkbox" id="histToggle" checked> Show Histogram
  </label>
  <label id="groupSelectLabel" style="display:none;">Grouping:
    <select id="groupSelect">
      <option value="hsl">HSL</option>
      <option value="gray">Grayscale</option>
    </select>
  </label>
  <label id="segmentsLabel" style="display:none;">Segments:
    <input type="range" id="segmentsRange" min="2" max="12" value="6">
  </label>
  <label id="rippleLabel" style="display:none;">Ripple Strength:
    <input type="range" id="rippleRange" min="0" max="100" value="50">
  </label>
</div>
<canvas id="canvas"></canvas>

<script>
// --- Global State ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let currentMode = 2;
let currentImage = null;       // Image object for current image
let currentImageData = null;   // ImageData (pixel data) of current image
let currentHistData = null;    // { r: [], g: [], b: [] } histogram counts for current image
// Ripple simulation buffers and parameters
let rippleWidth = 0, rippleHeight = 0;
let rippleMapPrev = null, rippleMapCurr = null;
let rippleOutput = null;      // ImageData for output (ripple-distorted image)
let rippleStrengthFactor = 1; // factor from rippleRange slider (1 = normal)
let lastOrientDropTime = 0;   // last time we added ripple due to orientation
// Wave distortion parameters
let wavePhase = 0;
let waveAmplitude = 20;       // will be adjusted by rippleStrength
// Kaleidoscope parameter
let kaleidoSegments = 6;
// Orientation values
let orientGamma = 0, orientBeta = 0;
// Animation loop control
let animating = true;

// --- Default Image (placeholder gradient) as Base64 ---
const defaultImageDataURL = "data:image/png;base64,<?php echo $b64_str_big ?? '' ?>";  /* Insert base64 string */

// If user has images in localStorage, load them into the image selector
let storedImages = [];
if (localStorage.getItem('images')) {
  try {
    storedImages = JSON.parse(localStorage.getItem('images'));
  } catch(e) { storedImages = []; }
}
const imgSelect = document.getElementById('imgSelect');
function refreshImageOptions() {
  // Remove all options except default
  for (let i = imgSelect.options.length - 1; i >= 1; i--) {
    imgSelect.remove(i);
  }
  // Add stored images
  storedImages.forEach((img, index) => {
    const opt = document.createElement('option');
    opt.value = index;  // use index in storedImages array
    opt.textContent = img.name ? img.name : "Image " + (index+1);
    imgSelect.appendChild(opt);
  });
}
refreshImageOptions();

// Utility: Load an image (from data URL) into an HTMLImageElement (returns a Promise)
function loadImage(dataURL) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = err => reject(err);
    img.src = dataURL;
  });
}

// Utility: Prepare image data (draw image to canvas, get ImageData)
function prepareImageData(img) {
  // Fit canvas size to image
  canvas.width = img.naturalWidth || img.width;
  canvas.height = img.naturalHeight || img.height;
  // Draw image onto canvas
  ctx.setTransform(1,0,0,1,0,0);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  // Get pixel data
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// Compute histogram counts for currentImageData
function computeHistogram() {
  if (!currentImageData) return null;
  const data = currentImageData.data;
  const len = data.length;
  const hist = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
  for (let i = 0; i < len; i += 4) {
    hist.r[data[i]]++;
    hist.g[data[i+1]]++;
    hist.b[data[i+2]]++;
  }
  return hist;
}

// Draw histogram overlay on current canvas
function drawHistogramOverlay() {
  if (!currentHistData) {
    currentHistData = computeHistogram();
  }
  const hist = currentHistData;
  // Determine overlay size (width 256 or less, height 100 or 25% of canvas)
  const histWidth = Math.min(256, Math.floor(canvas.width * 0.5));
  const histHeight = Math.min(100, Math.floor(canvas.height * 0.3));
  const offsetX = canvas.width - histWidth - 10;
  const offsetY = canvas.height - histHeight - 10;
  // Compute max frequency for scaling
  let maxFreq = 0;
  for (let v = 0; v < 256; v++) {
    if (v < hist.r.length) { // (defensive: hist arrays length 256)
      if (hist.r[v] > maxFreq) maxFreq = hist.r[v];
      if (hist.g[v] > maxFreq) maxFreq = hist.g[v];
      if (hist.b[v] > maxFreq) maxFreq = hist.b[v];
    }
  }
  const scaleY = (histHeight - 5) / maxFreq;  // leave some margin
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.globalAlpha = 0.7;
  // Draw a background for the histogram for visibility (optional)
  // ctx.fillStyle = "#000";
  // ctx.fillRect(0, 0, histWidth, histHeight);
  // Draw each channel's histogram
  ctx.lineWidth = 1;
  // Red channel
  ctx.beginPath();
  ctx.strokeStyle = "red";
  for (let x = 0; x < histWidth; x++) {
    // Map x to intensity value
    const v = Math.floor(x * 256 / histWidth);
    const h = Math.round(hist.r[v] * scaleY);
    ctx.moveTo(x, histHeight);
    ctx.lineTo(x, histHeight - h);
  }
  ctx.stroke();
  // Green channel
  ctx.beginPath();
  ctx.strokeStyle = "lime";
  for (let x = 0; x < histWidth; x++) {
    const v = Math.floor(x * 256 / histWidth);
    const h = Math.round(hist.g[v] * scaleY);
    ctx.moveTo(x, histHeight);
    ctx.lineTo(x, histHeight - h);
  }
  ctx.stroke();
  // Blue channel
  ctx.beginPath();
  ctx.strokeStyle = "cyan";
  for (let x = 0; x < histWidth; x++) {
    const v = Math.floor(x * 256 / histWidth);
    const h = Math.round(hist.b[v] * scaleY);
    ctx.moveTo(x, histHeight);
    ctx.lineTo(x, histHeight - h);
  }
  ctx.stroke();
  ctx.restore();
}

// Draw scatterplot (mode7) based on grouping (HSL or grayscale)
function drawScatterPlot(grouping) {
  ctx.setTransform(1,0,0,1,0,0);
  // Fill background
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const data = currentImageData.data;
  const w = canvas.width, h = canvas.height;
  if (grouping === "hsl") {
    // Plot each pixel by Hue and Lightness
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      // Convert RGB to HSL
      const rN = r/255, gN = g/255, bN = b/255;
      const max = Math.max(rN, gN, bN), min = Math.min(rN, gN, bN);
      let hVal, sVal, lVal;
      lVal = (max + min) / 2;
      if (max === min) {
        hVal = 0; sVal = 0;
      } else {
        const d = max - min;
        sVal = lVal > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
          case rN: hVal = ( (gN - bN) / d + (gN < bN ? 6 : 0) ); break;
          case gN: hVal = ( (bN - rN) / d + 2 ); break;
          case bN: hVal = ( (rN - gN) / d + 4 ); break;
        }
        hVal *= 60;
      }
      const hue = hVal; 
      const light = lVal * 100;
      // Determine plot coordinates
      const xPos = Math.round((hue / 360) * (w - 1));
      const yPos = Math.round((1 - light/100) * (h - 1));
      // Plot the point (1px dot)
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      ctx.fillRect(xPos, yPos, 1, 1);
    }
  } else if (grouping === "gray") {
    // Compute brightness counts for each intensity
    const brightnessCount = new Array(256).fill(0);
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      // perceived luminance (0-255)
      const lum = Math.round(0.299*r + 0.587*g + 0.114*b);
      brightnessCount[lum]++;
    }
    // Draw a vertical column for each brightness
    for (let val = 0; val < 256; val++) {
      if (brightnessCount[val] === 0) continue;
      const count = brightnessCount[val];
      const xPos = Math.round(val / 255 * (w - 1));
      const colHeight = Math.min(count, h);
      // Draw column of that many pixels (from bottom up)
      const yPos = h - colHeight;
      // Use grayscale color for the column
      ctx.fillStyle = `rgb(${val},${val},${val})`;
      ctx.fillRect(xPos, yPos, 1, colHeight);
    }
  }
}

// Update the canvas based on current mode (called on mode change or image change)
function renderCurrentMode() {
  ctx.setTransform(1,0,0,1,0,0);
  switch(currentMode) {
    case 1: // Static image
      ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
      break;
    case 2: // Continuous wave (initial draw; animation will continue in loop)
      ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
      // (animation frames will distort it, so initial draw just shows normal image momentarily)
      break;
    case 3: // Ripple (interactive) – start with undistorted image
      ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
      // Reset ripple simulation state
      initRipple();
      break;
    case 4: // Kaleidoscope
      drawKaleidoscope();
      break;
    case 5: // Liquid ripple (orientation) – start simulation
      ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
      initRipple();
      break;
    case 6: // Histogram overlay
      ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
      if (histToggle.checked) {
        currentHistData = computeHistogram();
        drawHistogramOverlay();
      }
      break;
    case 7: // Scatterplot
      // Prepare scatter by clearing background and drawing points
      drawScatterPlot(groupSelect.value);
      break;
  }
}

// Initialize ripple buffers for current image dimensions
function initRipple() {
  rippleWidth = canvas.width;
  rippleHeight = canvas.height;
  const size = rippleWidth * rippleHeight;
  rippleMapPrev = new Int16Array(size);
  rippleMapCurr = new Int16Array(size);
  rippleOutput = ctx.createImageData(rippleWidth, rippleHeight);
  // Pre-fill output with current image pixel data (as baseline)
  rippleOutput.data.set(currentImageData.data);
}

// Disturb ripple map at given canvas coordinates (adds an impulse)
function disturbRipple(x, y) {
  const rad = 3; // radius of disturbance
  const strength = 512 * rippleStrengthFactor;  // base disturbance, scaled by strength slider
  // Index in array
  for (let j = -rad; j <= rad; j++) {
    let yy = y + j;
    if (yy < 0 || yy >= rippleHeight) continue;
    for (let i = -rad; i <= rad; i++) {
      let xx = x + i;
      if (xx < 0 || xx >= rippleWidth) continue;
      const idx = yy * rippleWidth + xx;
      rippleMapCurr[idx] += strength;
    }
  }
}

// Compute one iteration of ripple simulation and update canvas pixels
function updateRippleFrame() {
  if (!rippleMapPrev || !rippleMapCurr) return;
  const width = rippleWidth, height = rippleHeight;
  const prev = rippleMapPrev, curr = rippleMapCurr;
  const newPrev = new Int16Array(width * height);  // we will reuse one of the buffers for next state
  const outData = rippleOutput.data;
  const origData = currentImageData.data;
  const stride = width; 
  // Neighbors indices offsets
  for (let y = 1; y < height-1; y++) {
    let idx = y * width;
    for (let x = 1; x < width-1; x++, idx++) {
      // wave propagation: newPrev = avg(curr neighbors) - prev[idx]
      const a = curr[idx - stride];
      const b = curr[idx + stride];
      const c = curr[idx - 1];
      const d = curr[idx + 1];
      let newHeight = ((a + b + c + d) >> 1) - prev[idx];
      // Damping
      newHeight -= newHeight >> 5;  // equivalent to newHeight *= 0.96875
      newPrev[idx] = newHeight;
      // Calculate refraction offset for this pixel
      // (Using approximation: offset by gradient)
      const dx = curr[idx - 1] - curr[idx + 1];
      const dy = curr[idx - stride] - curr[idx + stride];
      // Determine where to sample the original image
      let srcX = x + (dx * rippleStrengthFactor >> 5);
      let srcY = y + (dy * rippleStrengthFactor >> 5);
      if (srcX < 0) srcX = 0;
      if (srcX >= width) srcX = width - 1;
      if (srcY < 0) srcY = 0;
      if (srcY >= height) srcY = height - 1;
      const srcIdx = ((srcY * width) + srcX) * 4;
      const outIdx = (idx * 4);
      // Copy pixel from original to output at this pixel
      outData[outIdx]   = origData[srcIdx];
      outData[outIdx+1] = origData[srcIdx+1];
      outData[outIdx+2] = origData[srcIdx+2];
      outData[outIdx+3] = 255; // opaque
    }
  }
  // Swap buffers: what was curr becomes prev, newPrev becomes curr
  rippleMapPrev = curr;
  rippleMapCurr = newPrev;
  // Update the canvas with the output image data
  ctx.putImageData(rippleOutput, 0, 0);
}

// Draw kaleidoscope pattern for current image
function drawKaleidoscope() {
  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);
  const segments = kaleidoSegments;
  const angleStep = (2 * Math.PI) / segments;
  for (let i = 0; i < segments; i++) {
    ctx.save();
    // Clip to wedge shape
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    const theta0 = i * angleStep;
    const theta1 = (i+1) * angleStep;
    ctx.lineTo(cx + 10000 * Math.cos(theta0), cy + 10000 * Math.sin(theta0)); // line far out along edge
    ctx.lineTo(cx + 10000 * Math.cos(theta1), cy + 10000 * Math.sin(theta1));
    ctx.closePath();
    ctx.clip();
    // Rotate and draw image for this segment
    ctx.translate(cx, cy);
    ctx.rotate(theta0);
    if (i % 2 === 1) {
      // mirror every alternate segment
      ctx.scale(-1, 1);
    }
    // Draw image with its center at canvas center
    ctx.drawImage(currentImage, -cx, -cy, w, h);
    ctx.restore();
  }
}

// Animation loop
function animate() {
  if (currentMode === 2) {
    // Wave distortion: redraw image slices with phase shift
    const w = canvas.width, h = canvas.height;
    // Clear current canvas (fill with background color to avoid ghosting at edges)
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, w, h);
    // Draw each row with horizontal offset
    const amp = waveAmplitude * rippleStrengthFactor;
    const wavelength = h / 5;  // 5 waves vertically as an example
    for (let y = 0; y < h; y++) {
      const offsetX = Math.sin((y / wavelength) * (2*Math.PI) + wavePhase) * amp;
      // Draw one horizontal slice of the image at y
      ctx.drawImage(currentImage, 
        0, y, w, 1,          // src rect: full row y
        offsetX, y, w, 1     // dest rect: same y, shifted by offsetX
      );
    }
    // Update phase for next frame
    wavePhase += 0.1;
  }
  if (currentMode === 3 || currentMode === 5) {
    // Ripple simulation running
    // If orientation Mode5, possibly add disturbances at edges
    if (currentMode === 5) {
      const now = Date.now();
      const interval = 500; // ms between orientation-triggered drops
      if (now - lastOrientDropTime > interval) {
        const tiltX = orientGamma;
        const tiltY = orientBeta;
        const edgeStrength = 0.5; // partial strength for tilt
        if (tiltX > 15) {
          // tilt right
          disturbRipple(rippleWidth-1, Math.floor(rippleHeight/2));
          lastOrientDropTime = now;
        } else if (tiltX < -15) {
          // tilt left
          disturbRipple(0, Math.floor(rippleHeight/2));
          lastOrientDropTime = now;
        }
        if (tiltY > 15) {
          // tilt forward (device forward = canvas bottom)
          disturbRipple(Math.floor(rippleWidth/2), rippleHeight-1);
          lastOrientDropTime = now;
        } else if (tiltY < -15) {
          // tilt back (device toward user = canvas top)
          disturbRipple(Math.floor(rippleWidth/2), 0);
          lastOrientDropTime = now;
        }
      }
    }
    // Run ripple physics and draw
    updateRippleFrame();
  }
  // No animation needed for modes 1,4,6,7 except respond to user input events separately.
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// --- Event Handlers for UI ---
// Mode selection
document.getElementById('modeSelect').addEventListener('change', (e) => {
  currentMode = parseInt(e.target.value);
  // Show/hide relevant controls
  document.getElementById('histToggleLabel').style.display = (currentMode === 6) ? "" : "none";
  document.getElementById('groupSelectLabel').style.display = (currentMode === 7) ? "" : "none";
  document.getElementById('segmentsLabel').style.display = (currentMode === 4) ? "" : "none";
  document.getElementById('rippleLabel').style.display = ([2,3,5].includes(currentMode)) ? "" : "none";
  // If histogram mode and toggled off, ensure it draws appropriately
  if (currentMode !== 6) {
    histToggle.checked = true; // reset histogram toggle when leaving mode6
  }
  // Re-render the canvas for the new mode
  renderCurrentMode();
});

// Image selection
imgSelect.addEventListener('change', async (e) => {
  let choice = e.target.value;
  let dataURL;
  if (choice === "default") {
    dataURL = defaultImageDataURL;
  } else {
    // choice is index in storedImages array
    choice = parseInt(choice);
    if (!isNaN(choice) && storedImages[choice]) {
      dataURL = storedImages[choice].data;
    }
  }
  if (!dataURL) return;
  // Load the image data
  currentImage = await loadImage(dataURL);
  currentImageData = prepareImageData(currentImage);
  currentHistData = null;  // reset cached histogram
  // Reinitialize ripple if in ripple modes
  if (currentMode === 3 || currentMode === 5) {
    initRipple();
  }
  // Re-render current mode with the new image
  renderCurrentMode();
});

// Upload button triggers file input
document.getElementById('addImageBtn').addEventListener('click', () => {
  document.getElementById('fileInput').click();
});
// File input change (user selected files)
document.getElementById('fileInput').addEventListener('change', async (e) => {
  const files = Array.from(e.target.files);
  if (!files.length) return;
  for (let file of files) {
    if (storedImages.length >= 4) {
      alert("Maximum of 4 images can be stored.");
      break;
    }
    if (!file.type.startsWith('image/')) {
      continue; // skip non-images
    }
    const reader = new FileReader();
    reader.onload = () => {
      storedImages.push({ name: file.name, data: reader.result });
      localStorage.setItem('images', JSON.stringify(storedImages));
      refreshImageOptions();
      // Auto-select the newly added image
      imgSelect.value = storedImages.length - 1;
      const event = new Event('change');
      imgSelect.dispatchEvent(event);
    };
    reader.readAsDataURL(file);
    // Wait for each file to be read (not strictly necessary to await)
    await new Promise(r => setTimeout(r, 0));
  }
  // Clear the file input value so the same file can be selected again if needed
  e.target.value = "";
});

// Histogram toggle
const histToggle = document.getElementById('histToggle');
histToggle.addEventListener('change', () => {
  if (currentMode === 6) {
    ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
    if (histToggle.checked) {
      currentHistData = computeHistogram();
      drawHistogramOverlay();
    }
    // if unchecked, image is already drawn alone
  }
});

// Grouping selector for scatter
const groupSelect = document.getElementById('groupSelect');
groupSelect.addEventListener('change', () => {
  if (currentMode === 7) {
    renderCurrentMode(); // redraw scatter with new grouping
  }
});

// Kaleidoscope segments slider
document.getElementById('segmentsRange').addEventListener('input', (e) => {
  kaleidoSegments = parseInt(e.target.value);
  if (currentMode === 4) {
    drawKaleidoscope();
  }
});

// Ripple strength slider
document.getElementById('rippleRange').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  rippleStrengthFactor = val / 50;  // 50 = normal (1x), 100 = 2x, 0 = 0x
  waveAmplitude = 20; // base amplitude
  waveAmplitude *= (rippleStrengthFactor); // adjust wave amplitude
  // Note: ripple simulation uses rippleStrengthFactor in disturb and refraction calc
});

// Pointer events on canvas for interactive ripple
let pointerDown = false;
canvas.addEventListener('pointerdown', (e) => {
  pointerDown = true;
  if (currentMode === 3 || currentMode === 5) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
    disturbRipple(x, y);
  }
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', (e) => {
  if (!pointerDown) return;
  if (currentMode === 3 || currentMode === 5) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
    disturbRipple(x, y);
  }
});
canvas.addEventListener('pointerup', (e) => {
  pointerDown = false;
  canvas.releasePointerCapture(e.pointerId);
});
canvas.addEventListener('pointercancel', () => {
  pointerDown = false;
});

// Device orientation events (for Mode 5)
window.addEventListener('deviceorientation', (event) => {
  // gamma: left-right tilt, beta: front-back tilt
  if (event.gamma !== null && event.beta !== null) {
    orientGamma = event.gamma;
    orientBeta = event.beta;
  }
}, true);

// Initial setup: load default image and start in Mode 2 (wave)
(async function init() {
  currentImage = await loadImage(defaultImageDataURL);
  currentImageData = prepareImageData(currentImage);
  currentHistData = null;
  // Ensure initial controls visibility
  document.getElementById('histToggleLabel').style.display = "none";
  document.getElementById('groupSelectLabel').style.display = "none";
  document.getElementById('segmentsLabel').style.display = "none";
  document.getElementById('rippleLabel').style.display = ""; // Mode 2 uses ripple strength
  // Render initial mode
  renderCurrentMode();
})();
</script>
</body>
</html>
