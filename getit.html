
<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modular Image Visualizer</title>
  <style>
    html, body { margin: 0; padding: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
    #panel {
      position: absolute; top: 0; left: 0; background: rgba(0,0,0,0.8);
      padding: 10px; z-index: 10; border-bottom-right-radius: 8px;
    }
    label, select, input[type=file] { display: block; margin-bottom: 8px; }
    canvas { position: absolute; top: 0; left: 0; }
  </style>
</head>
<body>
<div id="panel">
  <label>Mode:
    <select id="mode">
      <option value="static">Static</option>
      <option value="wave">Wave</option>
      <option value="ripple">Ripple (Touch + Tilt)</option>
    </select>
  </label>
  <label>Choose Image:
    <select id="imageSelect"></select>
  </label>
  <label>Upload Image:
    <input type="file" id="upload" accept="image/*">
  </label>
</div>
<canvas id="canvas"></canvas>
<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const modeSel = document.getElementById('mode');
  const imageSel = document.getElementById('imageSelect');
  const uploadEl = document.getElementById('upload');
  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;
  window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    if (currentImage) drawStatic(currentImage);
  });let currentImage = null, currentData = null; const ripple = { buf1: null, buf2: null, out: null }; const tilt = { gamma: 0, beta: 0 }; let wavePhase = 0;

const defaultImage = new Image(); defaultImage.onload = () => { currentImage = defaultImage; ctx.drawImage(currentImage, 0, 0, width, height); currentData = ctx.getImageData(0, 0, width, height); setupRipple(); }; defaultImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAZUlEQVR4nO3PMQ0AAAjDMMZf9DhAx7BNZ0aQwIEDBgwYMGDAgAEDBgwYMGDAgAEDBgwYMGDAgAEDBgwYMGDAgAEDBgwYMGDAgAEDBgwYMGDAgAEDBgz4TAP+AVddW2vAAAAAElFTkSuQmCC';

const modeMap = { static: () => drawStatic(currentImage), wave: () => drawWave(currentImage), ripple: () => drawRipple(currentData) };

function drawStatic(img) { ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0, 0, width, height); ctx.drawImage(img, 0, 0, width, height); }

function drawWave(img) { wavePhase += 0.1; for (let y = 0; y < height; y++) { const offset = Math.sin((y / 40) + wavePhase) * 20; ctx.drawImage(img, 0, y, width, 1, offset, y, width, 1); } }

function setupRipple() { ripple.buf1 = new Float32Array(width * height); ripple.buf2 = new Float32Array(width * height); ripple.out = ctx.createImageData(width, height); }

function disturb(x, y) { const i = (Math.floor(y) * width + Math.floor(x)); if (i >= 0 && i < ripple.buf1.length) ripple.buf1[i] = 255; }

function drawRipple(imgData) { const src = imgData.data; const out = ripple.out.data; for (let y = 1; y < height - 1; y++) { for (let x = 1; x < width - 1; x++) { const i = y * width + x; const val = ( ripple.buf1[i - 1] + ripple.buf1[i + 1] + ripple.buf1[i - width] + ripple.buf1[i + width] ) / 2 - ripple.buf2[i]; ripple.buf2[i] = val * 0.99; const dx = ripple.buf2[i] - ripple.buf2[i - 1]; const dy = ripple.buf2[i] - ripple.buf2[i - width]; const sx = Math.min(width - 1, Math.max(0, x + dx * 0.5)); const sy = Math.min(height - 1, Math.max(0, y + dy * 0.5)); const si = (Math.floor(sy) * width + Math.floor(sx)) * 4; const di = i * 4; out[di] = src[si]; out[di+1] = src[si+1]; out[di+2] = src[si+2]; out[di+3] = 255; } } [ripple.buf1, ripple.buf2] = [ripple.buf2, ripple.buf1]; ctx.putImageData(ripple.out, 0, 0); if (tilt.gamma > 15) disturb(width - 10, height / 2); if (tilt.gamma < -15) disturb(10, height / 2); if (tilt.beta > 15) disturb(width / 2, height - 10); if (tilt.beta < -15) disturb(width / 2, 10); }

function tick() { if (!currentImage || !modeSel.value) return; ctx.clearRect(0, 0, width, height); modeMapmodeSel.value; requestAnimationFrame(tick); }

uploadEl.onchange = e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = () => { localStorage.setItem('image0', reader.result); const opt = new Option('Uploaded Image', '0'); imageSel.appendChild(opt); imageSel.value = '0'; loadImage(reader.result); }; reader.readAsDataURL(file); };

function loadImage(base64) { const img = new Image(); img.onload = () => { currentImage = img; ctx.drawImage(img, 0, 0, width, height); currentData = ctx.getImageData(0, 0, width, height); setupRipple(); }; img.src = base64; }

imageSel.onchange = () => { const src = localStorage.getItem('image0'); if (src) loadImage(src); };

window.addEventListener('deviceorientation', e => { tilt.gamma = e.gamma; tilt.beta = e.beta; });

if (localStorage.getItem('image0')) { const opt = new Option('Stored Image', '0'); imageSel.appendChild(opt); imageSel.value = '0'; loadImage(localStorage.getItem('image0')); }

requestAnimationFrame(tick); })(); </script>

</body>
</html>
